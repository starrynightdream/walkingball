---
title: c++的边学边记
date: 2021-09-05 13:36:59
tags:
- 学习
    + c++
thumbnail: /walkingball/images/86907186_p1.jpg
---

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=2 orderedList=false} -->

<!-- code_chunk_output -->

- [c++从头再学。按章节记录在意的知识点](#c从头再学按章节记录在意的知识点)
  - [未归类知识点](#未归类知识点)
  - [第 2 章 简单程序设计](#第-2-章-简单程序设计)
  - [第 3 章 函数](#第-3-章-函数)
  - [第 4 章 类与对象](#第-4-章-类与对象)
  - [第 5 章 数据共享与保护](#第-5-章-数据共享与保护)
  - [第 6 章 数组、指针与字符串](#第-6-章-数组-指针与字符串)
  - [第 7 章 继承与派生](#第-7-章-继承与派生)

<!-- /code_chunk_output -->

# c++从头再学。按章节记录在意的知识点

## 未归类知识点
### volatile 关键字
指示变量易变，程序应该每次使用时都去地址处读取。
当一个变量使用频繁的时候，编译器可能会进行优化，将其放置在寄存器中。但是如果这个变量是由其它程序进行修改的，可能就会使得这个变量不能同步修改。
它也会阻止编译器进行常量合并
因此建议在使用由其它程序修改的变量时，使用 $ volatile $ 关键字

[参考文章][volatile]

## 第 2 章 简单程序设计

### 四种强制转换
四者均采用 $cast-name<typename>(express)$ 的形式调用
#### const_cast (常量转换)
- 编译时处理
- 可用于基本类型转换
    + 常量指针或引用转换为非常量指针或引用，指向原对象
```c++
    using namespace std;

    void Printer (int* val,string seperator = "\n")
    {
        cout << val<< seperator;
    }

    int main(void) 
    {	
        const int consatant = 20;
        //Printer(consatant);//Error: invalid conversion from 'int' to 'int*'
        Printer(const_cast<int *>(&consatant));
        
        return 0;
    }
```
应当用于临时为未添加`const`的函数提供调用便利，而非修改`const`值。
#### dynamic_cast (动态转换)
- 运行时处理
- 不用于基本数据转换
- 可对类进行父子转换
    + 基类有虚函数方编译通过
    + 可向下转换返回子类指针，否则未NULL
    + 向上转换正常。
```c++
    dynamic_cast<int>(b);
    // 可参照后文static_cast的转换
```
#### reinterpret_cast (重解释)
- 编译时处理
- 不能去除const， volatile 属性
- 仅拷贝比特位
```c++
    unsigned short Hash(void * p)
    {
        unsigned int val = reinterpret_cast<unsigned int>(p);
        return (unsigned short) val;
    }

    int main ()
    {
        int a[20];
        for (int i=0; i<20; ++i)
            cout<< Hash(a + i) <<endl;
    }
```
它应该用在如：已知指针类型情况下转换为正确的指针。

#### static_cast (静态转换)
- 编译时处理
- 可用于基本类型转换
    + 不能去除const , volitale 属性
- 可对类进行父子转换
    + 向下转换不保证安全
    + 向上转换正常。
- 基础类型和对象的转换
    + 通过调用 $ 构造函数 $ 与 $ 类型转换函数实现 $
```c++
    class Parents
    {
    public:
        virtual ~Parents(){}
        /*codes here*/
    };

    class Children : public Parents
    {
        /*codes here*/
    };

    int main() 
    {	
        Children * daughter = new Children();
        Parents * mother = static_cast<Parents*> (daughter); //right, cast with polymorphism
        
        Parents * father = new Parents();
        Children * son = static_cast<Children*> (father); //no error, but not safe
    }
```

```c++
    int main(void) 
    {
        Ape a;
        Human h = static_cast<Human> (a); // using promtion constructor

        Programmer p;
        p = static_cast<Programmer> (h); // using  Programmer-cast operaotor

        //Ape a2;
        //a2 = static_cast<Ape> (p); //Error, assignment operator should be used directly

        return 0;
    }
```

### 简单IO格式控制
| 操作符名 | 含义 |
| - | - |
| dec | 数值采用10进制表示 |
| hex | 数值采用16进制表示 |
| oct | 数值采用8进制表示 |
| ws | 提取空白符 |
| endl | 插入换行符，并刷新流 |
| ends | 插入空字符 |
| setsprecision(int) | 设置浮点数的小数位数(包括小数点) |
| setw(int) | 设置域宽 |

### C++ 特点
1. 兼容C
2. 支持面向对象

### 常量
1. 整型常量
2. 实型常量
3. 字符常量
4. 字符串常量
5. 布尔常量

### 变量
变量在使用之前需要首先声明其类型和名称

### 符号常量
符号常量在使用之前一定要首先声明

### 表达式
> - 一个常量或标识对象的标识符是一个最简单的表达式，其值是常数或对象的值。
> - 一个表达式的值可以用来参与其它操作，即用作其它运算符的操作数，这就形成了更复杂的表达式。
> - 包括在括号中的表达式仍是一个表达式，其类型和值与未加括号时的表达式相同。

### 算术运算符
> 由算术运算符、操作数和括号构成的表达式称为算术表达式。

## 第 3 章 函数
- 在面向对象的程序设计中，函数是功能抽象的基本单位。
- 主调函数：调用其它函数的函数。
- 被调函数：被其它函数调用的函数

### 内联函数

> 内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处

> inline关键字仅表示要求，编译器不一定会将其编译为内联函数，而没有inline的函数也可能被编译为内联。
> - 有些函数一定不可以被编译为内联（如对自身存在引用的
> - 结构简单、语句少的容易被编译为内联。

> 内联与宏的区别
> - 内联函数在运行时可调试，而宏不可以
> - 内联函数可以访问类的成员变量，而宏不可以
> - 在类中声明同时定义的简单的函数，会自动转换为内联函数
> - 编译器会对内联函数的参数类型做安全检查
```c++
// 宏要带一个括号
#defind max(a,b) a>b?a:b 
max(a,b) +1;// a>b?a:b+1 有错误, 因此宏请带括号
```

### 默认形参值
- 不能在一个函数的多个声明中对同一个参数的默认值重复定义。
```c++
int add (int x=5, int y=3);
int main(){...}
int add (int x/*=5*/, int y/*=3*/){
    // 不可以再定义，但可以用注释告知。
}
```

### 函数重载
> 两个以上的函数，具有相同的函数名，但是形参的个数或者类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪一个函数。

### 运行栈
- esp寄存器记录栈顶地址。 即 `栈指针`
- ebp寄存器记录函数刚被调用时栈指针的位置。即`帧指针`
    + 局部变量和形参通过`帧指针`定位

## 第 4 章 类与对象 

### 抽象
> - 面向对象方法中的抽象，是指对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程。
> - 对一个问题的抽象应该包括：
>    + 数据抽象 (功能抽象)
>    + 行为抽象 (代码抽象)

### 封装
> 封装就是将抽象得到的数据和行为（或功能）相组合，形成一个有机整体，也就是将数据与操作数据的函数代码进行有机的结合，形成`类`，其中的数据和函数都是类的成员。

### 继承
### 多态
> - 多态性是指一段程序能够处理多种类型对象的能力。
> - 在C++中，这种多态可以通过：强制多态、类型参数化多态、包含多态4中形式来实现。

### 类和对象
> - 在面向对象程序设计中，程序模块是由类构成的。
> - 类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。

### 类成员的访问控制
- 公有类型 public:
    + 公有类型定义了类的外部接口
- 私有类型 private:
    + 私有成员只能被本类的成员函数访问，来自类外部的任何访问都是非法的。
- 保护类型 protected:
    + 继承过程中对产生的新类影响不同。

### 类的成员函数
#### 内联成员函数
> 隐式声明：将函数体写在类体内。
```c++
class A{
public: 
    void func(){
        // 这是一个内联成员函数
    }
}
```
> 显示声明： 使用`inline`关键字
```c++
inline void A::func(){
    // 这是一个内联成员函数
}
```

### 构造函数和析构函数
- 在定义对象的时候进行的数据成员设置，称为对象初始化

#### 构造函数
> 构造函数的作用就是：
> 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态
> - 构造函数在对象被创建的时候将被自动调用

#### 复制构造函数
> - 其形参是本类的对象的引用。
> - 其作用是使用一个已经存在的对象(由复制构造函数的参数指定)，去初始化同类的一个新对象。
> - 隐含的复制构造函数的功能：把初始值对象的每个数据成员的值都复制到新建立的对象中。 

#### 析构函数
> - 用来完成对象被删除前的一些清理工作
> - 析构函数是在对象的生存周期即将结束的时刻被自动调用的。

### 类的组合
#### 组合
- 类的组合就是一个类内嵌其它类对象作为成员的情况。
    + 它们之间的关系是一种包含和被包含的关系。
- 当创建类的对象时，如果这个类具有内嵌对象成员，那么各个内嵌对象将首先被自动创建。
    + 在创建对象时初始化基本类型数据成员和内嵌对象成员。

> - 内嵌对象的构造函数调用次序为其组合类的定义中出现的次序。与初始化列表中出现的顺序无关。
> - 析构函数的调用执行顺序与构造函数相反

### 结构体与联合体 (struct and union)
#### 结构体
> **类与结构体唯一区别**
> - 结构体默认访问权限为公共，类为私有。
#### 联合体
**联合体数据成员共享一组内存**

### 扩展
#### 位域
- C++未规定具体位域打包发生。由编辑器决定
- 支持位域的成员：bool、char、int、enum
- 时间换空间。因为打包解包需要时间。

```c++
#include <iostream>
using namespace std;
...// Level 的定义。含4个值。可用两bit存储
enum Grade {A, B, C, D} // 同理
class Student {
    ... //code there in P138
private:
    unsigned number:27; // 占27比特
    Level level: 2; // 占2比特
    Grade grade: 2; // 占2比特
}
... // code there
```
#### 显式临时对象
```c++
ClassName(ClassBasic(param), ClassBasic(param)); // 表达式结束对象被销毁
// 有以下等价写法。 P140
ClassName((ClassBasic)param, (ClassBasic)param);
ClassName(static_cast<ClassBasic>(param), static_cast<ClassBasic>(param));
```
对于等价写法，实际上就是根据构造函数创建了类型转换函数。若想避免，使用 `explicit` 关键字修饰构造函数。 (构造函数默认使用 `implicit` 关键字修饰)
```c++
class String{
public:
    explicit String(int n) {};
    String(const char *p) {};
};
```

#### 参数 和 返回值 传递对象
> **参数情况**
> - 调用复制构造函数，创建一个新类在参数部分。
> - 在某些情况（如传入临时对象）编译器会进行优化（传入临时对象则会在构造临时对象时就将其创建在被调函数的参数部分。）

> **返回值情况**
> *对如今大多数编译器而言*
> 先创建临时变量以保证返回值的空间，将地址告知被调函数，被调函数在地址处初始化对象。主调函数再将初始化的临时对象赋给目标值。
> 有优化为主调函数只分配空间，被调函数在空间上初始化类。

#### 拷贝构造函数 和 = 运算符
可以使用 `delete` 关键字阻止自动生成的 拷贝构造函数 和`=`运算符
```c++
class Person { // 这样类就不能使用值传递创建以及被赋值创建
public:
    Person(const Person& p) = delete;
    // disable Person p(other); and func(Person p);
    Person& operator=(const Person& p) = delete;
    // disable p = other;
};
```
- 拷贝构造函数必须以引用传参
- 调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。
    + 如果产生了新的对象实例，那调用的就是拷贝构造函数
        * 值方式传参
        * 值方式返回值
        * 使用一个对象初始化另一个对象
    + 如果没有，那就是对已有的对象赋值，调用的是赋值运算符。
        * a = b 等

## 第 5 章 数据共享与保护

### 作用域 
 **作用域是一个标识符正文中有效的区域**

#### 函数原型作用域
**在函数原型声明时形参的作用范围就是函数原型作用域**

#### 局部作用域
> - 形参列表中的形参： 从声明 到 函数体结束
> - 函数体内声明变量：从声明 到 所在块大括号结束
> - 访问类内部变量：
>    + 无同名局部变量，直接访问
>    + x.m 或 X::m 。x 是对象 X 是类。后者是访问静态变量。
>    + ptr->m。ptr为指针

#### 命名空间作用域
```c++
namespace name {
    // code there
}
namespaceName::operator // 使用其它命名空间内容
using namespaceName::operator // 引入一个操作
using namespace namespaceName; // 引入命名空间
```
命名空间可嵌套
```c++
namespace A{
    namespace B{
        operator;
    }
}
A::B::operator; // 使用
```
匿名空间常用于屏蔽不希望暴露给其它源文件的标识符。
```c++
namespace {
    // 不会暴露的内容
}
```
> **具有命名空间作用域的变量也称为全局变量**

#### 可见性
> 程序运行到某一点，能够引用到的标识符，就是该处可见的标识符
> - 声明在前，引用在后
> - 同一作用域，不能声明同名标识符
> - 不互相包含的作用域不互相影响
> - 内外同名标识符外层不可见

### 对象的生存期
#### 静态生存期
**如果对象的生存期于程序运行期相同，则称它具有静态生存期**

#### 动态生存期
**局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时**

### 类的静态成员
#### 静态数据成员
> - 使用`static`关键字
> - 类属性是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的。
> - 静态数据成员具有静态生存期
> - `类名::标识符`
#### 静态函数成员
> 静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名。

### 类的友元
> **友元机制提供了类的成员函数与其它类的成员函数或一般函数之间进行数据共享的机制**

#### 友元函数
类中用`friend`修饰的非成员函数
```c++
// P160
class A{
public:
    friend float dist(A a1, A a2); // 友元函数声明
    ...// code there 
}

float dist(A a1, A a2) {
    a1.operator; // 可以直接访问
    ... // code there
}
```
#### 友元类
若A类为B类的友元，则A类的所有成员函数都是B的友元函数
```c++
class B{
    ...
    friend class A; // 声明友元类
}
```
- 友元关系不能传递
- 友元关系是单向的
- 友元关系不能继承

### 共享数据的保护

#### 常对象
**常对象必须初始化，而且不能被更新**

#### 用const修饰类成员
#### 常引用
```c++
func(const className &p);
```

#### 多文件结构和预处理命令
##### 文件结构一般是分为
- 类定义
- 类实现
- 主函数

#### 外部变量与外部函数
##### 外部变量
`extend` 关键字修饰。可以在定义它的源文件以外的文件使用。
```c++
// 源文件1
int i=3;
void next();
int main(){
    i++; next();
    return 0;
}

void next() {
    i++; other();
}
// 源文件2
extern int i;
void other(){
    i++;
}
```
##### 外部函数
非成员函数，都可以在不同的编译单元中被使用。只要在调用之前进行引用性声明（即声明函数原型）即可。

##### 将变量和函数限制在编译单元内
> 现在推荐使用匿名空间变量。

#### 标准 C++ 库
> - 输入输出类
> - 容器类与ADT（抽象数据类型）
> - 存储管理类
> - 算法
> - 错误处理
> - 运行环境支持

#### 编译预处理
##### #include
```c++
#include <文件名> //标准方式，在系统目录的include子目录下搜索
#include "文件名" //在当前目录下搜索，再用标准方式
```

##### #define #undef
define 定义
undef 取消 define 的定义

##### 条件编译指令
```c++
# if 常量表达式
    code there
# elif 常量表达式
    code there
# else
    code there
# endif
```

##### defined

#### 代码的编译链接与执行过程
##### 编译
由 .cpp 产生 .o

## 第 6 章 数组、指针与字符串
### 数组
> 数组是具有一定顺序关系的若干对象的集合体，组成数组的对象称为该数组的元素。
> - 每个元素有n个下标的数组叫n维数组

声明：
- 确定数组的名称
- 确定数组元素的类型
- 确定数组的结构（包括数组维数，每一维数的大小)

*数组在内存中是顺序、连续存储的*
*数组的初始化是在声明数组时给部分或全部元素赋初值*
*数组名传参，传递的是地址*
*数组名传参，传递的是地址*

### 指针
*指针变量是用于存放内存单元地址的*

- `*` 表解析
- `&` 表取址

*数组名称实际上就是一个不能被赋值的指针，即指针常量*

> **指向常量的指针**
> ```c++
> const int* p1= &a; // 不能修改p1指向的内容
> ```
> **指针类型的常量**
> ```c++
> int* const p1= &a; // 不能修改p1
> ```
>

> *指针加减n为指向前后n个长度的元素*
> *0专用于表示空指针，也就是一个不指向任何有效地址的指针*

#### 指针数组
```c++
int * pLine[3] = {p1, p2, p3};
pLine[1][1]; // 然后这样用
```

#### 指针型函数
数据类型 (* 函数指针名) (形参表)
```c++
// 因为写法比较繁琐，一般使用typedef简化
typedef int (* DoubleIntFunc)(double); 
DoubleIntFunc funcPtr; // 一个指向参数为一个double，返回int 的函数指针
```

### 字符串
string 类

### 扩展
*引用底层是指针*
#### 指针的安全隐患及其应对方案
> **地址安全性**
> - 指针算术运算的用途，一定要限制在获得同个数组内其它元素指针上
> - 并注意通过首元素进行运算。
> - 或直接使用封装的数组 （如 `vector` ）

> **类型安全性**
> - reinterpret_cast 保证：
>   + A类型的 p 转换为 B类型的 q 再转回 A类型的r后有 ` p == r ` 成立
> - 但是对于void的转换使用 static_cast 会更有保证

> **堆对象管理**
> - 用`new`创建的对象用`delete`删除
> - 最好由哪个对象创建，就由哪个对象删除。
> - 对于使用函数创建需要的对象的情况，则需要对接口进行约定（写好注释），由调用者进行删除。
> - 或使用共享指针 如 Boost库

> **const_cast的应用**
> 不应该用于出尔反尔地去除 `const` 修改变量。而应该为未保证不修改但确实不修改的函数提供临时的便利。

## 第 7 章 继承与派生
### 类的继承与派生
> 类的继承，是新的类从已有类那里得到已有的特性。
> 从已有类产生新类的过程就是类的派生

一个派生类，可以同时有多个基类，这种情况称为多继承
一个派生类只有一个直接积累的情况称为单继承。

---------

[volatile]: https://blog.csdn.net/ydar95/article/details/69822540